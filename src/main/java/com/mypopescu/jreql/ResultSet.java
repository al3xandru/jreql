package com.mypopescu.jreql;

import com.mypopescu.jreql.internal.DatumConverter;

import java.util.Arrays;
import java.util.List;

/**
 * A sequence of database results generated by querying the database.
 *
 * While the implementation hides it, RethinkDB's results sets are batch-based.
 * When iterating over a <code>ResultSet</code> using {@link #next()}, if the
 * end of the current set of data was reached, there'll be an additional
 * server request.
 *
 * @author alex
 * @version 1.0, 5/19/13 12:48 AM
 */
public class ResultSet {
    private final Connection m_connection;
    private final ReqlProto.Term m_query;
    private final int m_token;
    private final boolean m_complete;

    private List<ReqlProto.Datum> m_data;
    protected int m_currentIndex;

    public ResultSet(Connection c, ReqlProto.Term query, int token, List<ReqlProto.Datum> data, boolean complete) {
        m_connection= c;
        m_query= query;
        m_token= token;
        m_complete = complete;
        m_currentIndex= -1;
        m_data= data;
    }

    public boolean next() {
        if (m_data == null) {
            return false;
        }
        m_currentIndex++;

        if(!m_complete && m_currentIndex == m_data.size()) {
            m_connection.run(m_query, ReqlProto.Query.QueryType.CONTINUE, this);
        }
        return m_currentIndex < m_data.size() - 1;
    }

    public boolean first() {
        if (m_data == null) {
            return false;
        }

        m_currentIndex = 0;
        return true;
    }

    /**
     * Closes the current result set by sending
     * the server a <code>STOP</code> query to
     * release any allocated resources.
     */
    public void close() {
        m_connection.run(m_query, ReqlProto.Query.QueryType.STOP, this);
    }

    /**
     * Tests if the current result set is empty.
     *
     * @return <code>true</code> if empty, <code>false</code> otherwise
     */
    public boolean isEmpty() {
        return m_data == null || m_data.size() == 0;
    }

    public boolean getBool() {
        return DatumConverter.getBool(m_data.get(m_currentIndex));
    }

    public int getInt() {
        return DatumConverter.getInt(m_data.get(m_currentIndex));
    }

    public long getLong() {
        return DatumConverter.getLong(m_data.get(m_currentIndex));
    }

    public double getDouble() {
        return DatumConverter.getDouble(m_data.get(m_currentIndex));
    }

    public String getString() {
        return DatumConverter.getString(m_data.get(m_currentIndex));
    }

    public boolean[] getBoolArray() {
        return DatumConverter.getBoolArray(m_data.get(m_currentIndex));
    }

    public int[] getIntArray() {
        return DatumConverter.getIntArray(m_data.get(m_currentIndex));
    }

    public long[] getLongArray() {
        return DatumConverter.getLongArray(m_data.get(m_currentIndex));
    }

    public double[] getDoubleArray() {
        return DatumConverter.getDoubleArray(m_data.get(m_currentIndex));
    }

    public String[] getStringArray() {
        return DatumConverter.getStringArray(m_data.get(m_currentIndex));
    }

    public JsonObject[] getObjArray() {
        return DatumConverter.getObjArray(m_data.get(m_currentIndex));
    }

    public Object[] getArray() {
        return DatumConverter.getArray(m_data.get(m_currentIndex));
    }

    public JsonObject getObj() {
        return DatumConverter.getObj(m_data.get(m_currentIndex));
    }

    public <T> T get() {
        return DatumConverter.get(m_data.get(m_currentIndex));
    }

    protected int getToken() {
        return m_token;
    }

    protected ResultSet append(List<ReqlProto.Datum> data) {
        m_data.addAll(data);
        return this;
    }

    public static class SingleResultResultSet extends ResultSet {
        public SingleResultResultSet(Connection c, ReqlProto.Term query, int token, ReqlProto.Datum data) {
            super(c, query, token, Arrays.asList(data), true);
        }

        public boolean next() {
            m_currentIndex++;
            return m_currentIndex == 0;
        }

        /**
         * For single result sets, close is a no-op.
         */
        public void close() {
            // no-op
        }
    }

    public static class EmptyResultSet extends SingleResultResultSet {
        public EmptyResultSet(Connection c, ReqlProto.Term query, int token) {
            super(c, query, token, null);
        }

        public boolean isEmpty() {
            return true;
        }

        public boolean next() {
            return false;
        }

        public boolean first() {
            return false;
        }

        /**
         * For single result sets, close is a no-op.
         */
        public void close() {
            // no-op
        }
    }
}
